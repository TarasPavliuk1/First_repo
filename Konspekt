
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ТИЖДЕНЬ 1 ТИПИ ДАНИХ >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# присвоюємо змінні
first_name = "Тарас"
last_name = "Павлюк"

#  поміщаємо дві змнні в один рядок 
first_name = "Тарас"
last_name = "Павлюк"
full_name =f"{first_name} {last_name}"
print (full_name)

#  поміщаємо три змнних в один рядок, робимо з 2х одні і поміщамо фул наме і першу в кінцевий рядок
first_name = "John"
last_name = "Smith"
full_name = f"{first_name} {last_name}"
message = f"Dear {first_name}, we inform island of Mauritius. Have a passport at {full_name}. you!"

# розрахунок площі кімнати при двох відомих змінних
length = 2.75
width = 1.75
area = length * width
show = f"With width {width} and length {length} of the room, its area is equal to {area}"
print(show)

# додавння комплексних змінних
a = -2 + 3j
b = 4 + 2.1j
result = a + b

# чотири типи рядків
name = "JOHN"  # рядкова змінна стрінг str
age = 34 # числова змінна int
is_active = True  # булева змінна True або False
subscription = None # нічого, встановити значення

# зміна типу str на чисельний
length = "2.75"
width = "1.75"
area = float(length) * float(width)

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ТИЖДЕНЬ 2 Керуючі конструкції. Винятки !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# при введенні користувачем більше 83 True менше False
is_next = None
num = int(input("Enter the number of points: "))
if num >= 83:
    is_next = True
if num < 83:
     is_next = False

# три логічні змінні користувач має доступ якщо is_active і is_permission True
# Адмін має доступ незалежно від is_active і is_permission
# Змінна access показує чи є доступ у користувача

is_active = input("Is the user active? ")
is_admin = input("Is the user administrator? ")
is_permission = input("Does the user have access? ")

is_admin = bool (is_admin)
is_active = bool (is_active)
is_permission = bool (is_permission)
if is_active == True and is_permission == True :
    access = True
if is_active == False and is_permission == True :
    access = False
if is_admin == True :
    access = True 
access = is_admin or (is_active and is_permission)

# При введені число показує досвід роботи < 1 року "Junior", >1 <=5  "Middle", інше число "Senior"

work_experience = int(input("Enter your full work experience in years: "))

if work_experience > 1 and work_experience <= 5 :
    developer_type = "Middle"
elif work_experience <= 1:
    developer_type = "Junior"
else:
    developer_type = "Senior"

# при введенні числа показує чи воно парне чи ні, чи відємне чи нуль
num = int(input("Enter a number: "))

if num > 0: # умова перевірки
    if num % 2: # умова перевірки
        result = "Positive odd number" # додатнє парне число
    else:
        result = "Positive even number" # додатне не парне число
elif num < 0:
    result = "Negative number" # відємне число 
else:
    result = "It is zero" # це нуль

# визначає чи парне число чи ні за допомогою тернарного оператора
num = int(input("Enter an integer number: "))
is_even = True if num % 2 == 0 else False
print(is_even)

# Користувач вводить число від 0 до 100. Підрахуйте, використовуючи цикл while, суму всіх чисел від першого до введеного числа включно в num.
#  Результат помістити в змінну sum.

num = int(input("Enter the integer (0 to 100): "))
sum = 0 # початкова умова 
i = 1 # змінна яку ми додали для умови
while i <= num: # умова циклу 
    sum = sum + i # додаємо поточне число до суми
    i = i + 1 # збільшуємо поточне число на 1 для продовження циклу

# приклад цикл for

fruit = 'apple'
for char in fruit:
    print(char)
# виведе
# a
# p
# p
# l
# e

# приклад цикл while
# виводить числа від 1 до 5

a = 1 # початкова умова 
while a <= 5: # умова
    print(a)
    a = a + 1 # крок


# цикл while 
# виводить цифри від 0 до 20 доки не спрацює умова  break

a = 0 # початкова умова 
while True: # початок циклу
    print(a)
    if a >= 20: # умова циклу
        break
    a = a + 1 # крок виводу

# Приклад з завершенням continue
a = 0 # початок 
while a < 6: # цикл умови 
    a = a + 1 # крок
    if not a % 2: # умова (перевірка на непарність)
        continue
    print(a)

# цикл while  
while True: 
    number = input("number = ") # вводимо число
    number = int(number) # переводимо в інт
    while True: 
        print(number) # виводимо на екран
        number = number - 1 # крок в даному випадку відємний
        if number < 0: # умова при якій зупиняється цикл
            break
    break
       



# ВИНЯТКИ
# приклад try i except

age = input("How old are you? ") # вводимо вік
try: # початок винятку
    age = int(age)  # переводимо в інт
    if age >= 18:  # умова винятку 
        print("You are adult.") # виводимо на екран
    else: # якщо if False тоді спрацьовує else
        print("You are infant") # виводимо на екран при спрацюванні else
except ValueError: # закінчення винятку обов'язкове потрібно написати правильну помилку
    print(f"{age} is not a number") # виводимо


#     ВИДИ ПОМИЛОК
# SyntaxError — синтаксична помилка.

# IndentationError — помилка, яка виникає, якщо у виділенні блоків інструкцій пробілами припущена помилка.

# TabError виникає, якщо в одному файлі використовувати пробіли і табуляції для виділення блоків інструкцій.

# TypeError виникає, коли операція зі змінною цього типу неможлива. 2 / 'a'

# ValueError виникає, коли тип операнда відповідний, але значення таке, що операцію неможливо виконати. int("a")

# ZeroDivisionError — ділення на нуль.


# Напишіть два цикли, вкладені один в один. У першому циклі while ми постійно запитуємо ціле число,
# а у другому з допомогою циклу for складаємо суму чисел від 0 до введеного числа включно і додаємо до змінної sum.
# Змінна sum накопичує суми, що утворюються при кожному введенні числа. Вихід з першого циклу здійснюємо, якщо ми ввели число 0.
num = int(input("Enter integer (0 for output): "))
sum = 0
while num != 0:
    for i in range (num + 1):
         sum += i
    num = int(input("Введіть число (0 для виходу): "))  
#  або це завдання можна так написати так краще
sum = 0
while True:
    num = int(input("Enter integer (0 for output): "))
    if num == 0:
        break
    for i in range(num + 1):
        sum = sum + i


# Напишіть два подвійні цикли. У першому циклі while ми постійно запитуємо ціле число, а у 
# другому за допомогою циклу for обчислюємо суму парних чисел від 0 до введеного числа.
# Вихід з першого циклу здійснюємо, якщо ввели число 0 за допомогою оператора break.

sum = 0
while True: # починаємо цикл
    num = int(input("Enter integer (0 for output): ")) # вводимо число
    if num == 0: # умова циклу щоб нум не дорівнював 0
        break # якщо 0 то цикл зупиняється
    for i in range(num + 1): # поч цикл фор, цикл від 0 до num +1
        if i % 2 == 0: # перевірка на парність
            
           sum = sum + i # збільшення sum на i



#  КОД ЦЕЗАРЯ Дві нові функції
# ord Вона перетворює символ на число, яке є позицією в таблиці ASCII.    ord("a")  # це  97
# chr Зворотна функція повертає рядковий символ у таблиці ASCII за позицією, переданою як аргумент.     chr(118)  # 'v'

message = input("Enter a message: ")
offset = int(input("Enter the offset: "))
encoded_message = ""
for ch in message:
     if "a" <= ch <= "z": # рамки пошуку ch 
         pos = ord(ch) - ord('a') # 
         pos = (pos + offset) % 26 #
         new_char = chr(pos + ord("a")) #
         encoded_message = encoded_message + new_char #
     elif "A" <= ch <= "Z":
          pos = ord(ch) - ord('A')
          pos = (pos + offset) % 26
          new_char = chr(pos + ord("A"))
          encoded_message = encoded_message + new_char
     else :
          encoded_message = encoded_message + ch


# Напишіть програму, яка буде виконувати найпростіші математичні операції з числами послідовно, приймаючи від користувача операнди (числа) та оператор.
result = None
operand = None
operator = None
wait_for_number = True

while True:
    user_input = input(">>>> ") 
    if user_input == "=": 
        break 
    if wait_for_number: 
        try:
            operand = float(user_input) 
        except ValueError: # якщо користувач ввів символ спарцьовує except
            print(f"{user_input} is not a number")
            continue
        wait_for_number = False
        if result is None:
            result = operand
        else :
             if operator == "+":
                    result += operand
             elif operator == "-":
                    result -= operand
             elif operator == "*":
                    result *= operand 
             elif operator == "/":
                 if operand == 0:
                      print("Division by Zero")
                      continue
                 result /= operand
    else:
            if user_input in "=-+*/":
                operator = user_input
            else:
               operator= None
            if operator is None:
                print(f'{user_input} is not "+", "-", "*", "/"')
            else:
                wait_for_number = True

print(f"Result: {result}")

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    ТИЖДЕНЬ  3.  Функції   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Створіть функцію greeting, яка всередині виводить вітальне повідомлення print('Hello world!'). І викличте її.
def greeting():
    print("Hello world!")
greeting()

# Нехай нам необхідно створити розсилку запрошень на якийсь захід. Повідомлення для кожного учасника однакове, нам необхідно міняти лише ім'я запрошеного. 
# Цілком очевидно, що для формування такого повідомлення краще використовувати функцію. Створіть функцію invite_to_event, яка приймає ім'я запрошеного username і 
# повертатиме наступний f-рядок: "Dear {username}, we have the honour to invite you to our event".

def invite_to_event(username):
    # if username = input("Your username"):
    return f"Dear {username}, we have the honour to invite you to our event"
invite_to_event(1)

# Необхідно написати функцію, яка буде обчислювати суму за користування послугами таксі. Сума складається з базового тарифу 40 грн, та 10 грн за кожен кілометр поїздки.
# Напишіть функцію, яка приймає один параметр — відстань поїздки в кілометрах. Функція має повертати підсумкову суму оплати за послуги таксі дійсним числом. 
# Також функція повинна змінювати глобальну змінну — лічильник total_trip після кожного виклику та збільшувати її на одиницю.

base_rate = 40
price_per_km = 10
total_trip = 0


def calculate_trip_price(distance_km):
    global total_trip
    sum = base_rate + price_per_km * distance_km
    total_trip = total_trip + 1
    
    return sum

# Необхідно реалізувати функцію розрахунку ціни товару зі знижкою discount_price. Функція приймає ціну price та знижку discount — це дрібне число від 0 до 1. 
# Тут і надалі ми під знижкою розумітимемо коефіцієнт, який визначає розмір від ціни. І на цей розмір ми знижуємо підсумкову вартість товару. 
# Логіку функції необхідно прописати у внутрішній функції apply_discount, використовуючи оголошення зміною price як nonlocal.

def discount_price(price, discount):
    def apply_discount():
        nonlocal price
        price = price - (price * discount)
        
        
        

    apply_discount()
    return price

#Напишімо функцію, яка повертає повне ім'я користувача. У базі даних переважно зберігають ім'я користувача first_name, його прізвище last_name та по батькові,
#  або, як заведено в західних країнах, друге ім'я — middle_name. Причому middle_name — це необов'язкова змінна, вона може бути,
#  а може й не передаватися під час виклику функції. Наша функція повертатиме рядок з повним ім'ям 'first_name middle_name last_name',
#  якщо ж змінна middle_name відсутня, то рядок, що повертається повинен бути 'first_name last_name'.

def get_fullname (first_name, last_name, middle_name = None):
    if middle_name:
        return f"{first_name} {middle_name} {last_name}"
    else :
        return f"{first_name} {last_name}"
    
# Створіть функцію format_string для форматування рядка. У функцію ми передаємо рядок string та length довжину нового рядка. 
# Функція повертає новий рядок за наступним алгоритмом: Якщо довжина вихідного рядка більша або дорівнює length, ми повертаємо його в тому ж вигляді;
# Якщо вона менша length, ми додаємо попереду рядка пробіли в кількості (length - len(string)) // 2.

def format_string(string, length): #створюємо функцію 
    if len(string) >= length: # умова фінкції
        return string # що повертає функція
    else:   # умова якщо if не виконується
        space = (length - len(string)) // 2 # додаємо змінну пробіли
        format = ' ' * space + string  # додаємо змінну формат щоб зібрати се разом пробіли і рядок
        return format

# Створіть дві функції:
# перша first буде мати першим параметром змінну size, а також вона може приймати будь-яку кількість позиційних аргументів. Функція повинна повернути суму size
# із загальною кількістю переданих до неї позиційних аргументів. Друга функція second так само матиме першим параметром size і прийматиме довільну кількість ключових аргументів,
# і також має повернути суму size з кількістю переданих у функцію ключових аргументів.

def first(size, *args ):
    return size + len(args)

def second(size, **kwargs ):
    return size + len(kwargs)
# Магазин товарів за ціною 5$ за перший товар у замовленні та 2$ - за всі наступні товари. Необхідно реалізувати функцію, яка приймає як перший параметр кількість товарів
# у замовленні quantity, але також має бути присутнім параметр, що передається тільки за ключем discount. Параметр discount за замовчуванням має значення 0 - знижки немає.
# Приймає значення від 0 до 1. Функція cost_delivery повертає загальну суму за доставлення товару з урахуванням знижки.Треба передбачити, що функція cost_delivery 
# при визові може приймати будь-яку кількість позиційних аргументів.

def cost_delivery(quantity, *_, discount= 0):
    result = (5 + 2 * (quantity -1)) * (1 - discount)
    return result
    cost_delivery

# Для функції попереднього завдання створіть рядки документації. Можна використовувати наступний шаблон
def cost_delivery(quantity, *_, discount=0):
    """Функція повертає суму за доставлення замовлення.

     Перший параметр &mdash; кількість товарів в замовленні.
     Параметр знижки discount, який передається лише як ключовий, за замовчуванням має значення 0."""
    

    
    
    result = (5 + 2 * (quantity - 1)) * (1 - discount)
    return result


# Ми проводимо розіграш призів серед перших 50 підписників ютуб-каналу. Ми маємо 7 призів для розіграшу. 
# Може виникнути питання, скільки різних списків переможців ми можемо отримати під час розіграшу? Для цього ми будемо використовувати формулу сполучень без повторень
# Cnk = n! / ((n - k)! · k!) де n — це загальна кількість людей (випадків), а k — кількість людей, які отримали призи.
# Напишіть функцію number_of_groups, яка приймає параметри n та k, і за допомогою функції factorial повертає нам скільки різних списків переможців, скільки 
# ми можемо отримати при розіграші
# Використовуємо Рекурсію для функції(рекурсія це функція як викликає саму себе) або функція у функції

def factorial(n):   #  
    if n == 0 or n == 1: # умова факторіалу
        return 1 # базовий випадок
    else:
        return n * factorial(n - 1) # рекурсивний випадок
    

def number_of_groups(n, k): # функція яка використовує рекурсію першої функції
    C = factorial(n) / (factorial(n - k) * factorial(k)) # формула сполучень без повторень дана нам з умови
    return int(C) # повертаємо значення C 


# КОД Фібоначі 

def fibonacci(n): # функція рекурсії
    if n == 0: 
        return 0 # умова 1 якщо 0 то повертаємо 1
    if n == 1:
        return 1 # умова 2 якщо 1 то повертаємо 1
    else: 
        return fibonacci(n - 1) + fibonacci (n - 2)  # Формула Фібоначі , була дана в умові
    
    
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   ТИЖДЕНЬ 4. Структури даних   <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# Для створення порожнього списку існує два способи:

my_list = list()

empty_list = []

# Щоб створити заповнений список:

not_empty = [1, 2, 'user']

# У Python синтаксис доступу за індексом виглядає так:

some_iterable = ["a", "b", "c"]
first_letter = some_iterable[0]
middle_one = some_iterable[1]
last_letter = some_iterable[2]

# Найкориснішою властивістю списків є змінність списків, ви можете змінити значення будь-якого елементу списку:

some_iterable = ["a", "b", "c"]
some_iterable[1] = "Z"
print(some_iterable)    # ["a", "Z", "c"]

# Зрізи у Python (Slice)

some_str = "This is awesome string"
first_five = some_str[0:5]

# first_five в цьому прикладі буде містити рядок 'This '.

# Доступ до методів об'єктів у Python синтаксично відбувається за допомогою символу крапки після імені об'єкту і 
# зазначення імені методу або атрибуту, до якого потрібно отримати доступ.

numbers = ['a', 'b']
numbers.append('c')
print(numbers)  # ['a', 'b', 'c']

# Якщо метод не вимагає аргументів (наприклад метод clear), то дужки будуть порожніми:

num = [1, 2]
num.clear()
print(num)  # []

#                     >>>>>>  Методи списків <<<<<<<<<<

# >>>>>>>>>>     Списки !!!      приклад списку :   numbers = ['a', 'b']  <<<<<<<<<<<<<<<<<


# Додавання елементу в кінець списку: my_list.append(element)

chars = ['a', 'b']
chars.append('c')
print(chars)  # ['a', 'b', 'c']

# видалення елементу зі списку викличе помилку, якщо такого елементу немає в списку: my_list.remove(element)

chars = ['a', 'b']
chars.remove('b')
print(chars)  # ['a']

# Повернути i-ий елемент та видалити його зі списку i_element = my_list.pop(i). За замовчуванням i = -1

chars = ['a', 'b']
last = chars.pop(1)
print(chars)  # ['a']
print(last)  # 'b'

# Розширити список a_list елементами з b_list: a_list.extend(b_list)

chars = ['a', 'b']
numbers = [1, 2]

chars.extend(numbers)
print(chars)  # ['a', 'b', 1, 2]

# Вставити x на позицію з індексом i: my_list.insert(i, x)

chars = ["a", "b"]
chars.insert(1, "c")
print(chars)  # ['a', 'c', 'b']

# Очистити список: my_list.clear()

chars = ['a', 'b']
last =  chars.clear() 
print(chars) # []

# Знайти індекс першого елемента у списку, що дорівнює x: index = my_list.index(x)

chars = ['a', 'b', 'c', 'd']
c_ind = chars.index('c') 
print(c_ind) #2

# Повернути кількість елементів у списку, що дорівнюють x: x_number = my_list.count(x)

chars = ['a', 'b', 'c', 'a']
a_count = chars.count('a')
print(a_count) # 2

# Відсортувати список за зростанням: my_list.sort(key=None, reverse=False)

chars = ['z', 'a', 'b']
chars.sort()
print(chars) # ['a', 'b', 'z']

# Змінити порядок елементів у списку на зворотний: my_list.reverse()

chars = ['a', 'b']
chars.reverse()
print(chars) # ['b', 'a']

# Повернути копію списку: copy_of_my_list = my_list.copy()

chars =  ['a', 'b']
chars_copy = chars.copy()
chars == chars_copy # True

# >>>>>>>>>>>>  Словники  приклад рядка словника :  chars = {'a': 1, 'b': 2}   <<<<<<<<<<<

# >>>>>>>>>>  Методи словників <<<<<<<<

# Деякі методи словників, що найчастіше використовуються:

# pop(key) — повертає значення елементу і видаляє пару ключ-значення зі словника

chars = {'a': 1, 'b': 2}
b_num = chars.pop('b')
print(chars)  # {'a': 1}
print(b_num)  # 2

# update(another_dict) — розширює словник значеннями з іншого словника

chars = {'a': 1, 'b': 2}
chars.update({"c": 3})
print(chars)  # {'a': 1, 'b': 2, "c": 3}

# clear() — очищає словник, не створюючи нового

chars = {'a': 1, 'b': 2}
chars.clear()
print(chars)  # {}

# copy() — повертає копію словника

chars = {'a': 1, 'b': 2}
chars_copy = chars.copy()
chars_copy == chars  # True

# get(key[, default]) — не викликає виключення, якщо ключа немає в словнику, повертає default, за замовчуванням default=None.

chars = {'a': 1, 'b': 2}
c_idx = chars.get('c', -1)
print(c_idx)  # -1


# >>>>>>>>>>>> Множини приклад множин : a = set('hello') АБО  b = {1, 2, 3, 4}  <<<<<<<<<<<<<<<<<<
# Множини — це неврегульований контейнер, який містить тільки унікальні елементи. У множину можна додавати тільки незмінні типи даних.

# Є тільки один спосіб створити порожню множину:

a = set()
print(a)    # set()

# Для створення заповненої множини достатньо передати будь-який об'єкт, що ітерується, в функцію set:

a = set('hello')
print(a)    # {'e', 'h', 'l', 'o'}

# Або ж скористатися синтаксисом з фігурними дужками (як у словниках), але елементи у фігурних дужках просто перелічити через кому без двокрапок:

b = {1, 2, 3, 4}

# Унікальність має на увазі, що якщо множина вже містить такий елемент, то спроба додати ще один такий самий нічого не змінить.

numbers = {1, 2, 3, 1, 2, 3}
print(numbers)    # {1, 2, 3}


# Методи множин

# Множини підтримують наступні методи:

# add(elem) — додає елемент в множину

numbers = {1, 2, 3}
numbers.add(4)
print(numbers)    # {1, 2, 3, 4}

# remove(elem) — видаляє елемент з множини, викликає виняток, якщо такого елементу немає

numbers = {1, 2, 3}
numbers.remove(3)
print(numbers)    # {1, 2}

# discard(elem) — видаляє елемент з множини і не викликає виняток, якщо його немає

numbers = {1, 2, 3}
numbers.discard(2)
print(numbers)    # {1, 3}

#  >>>>>>>>> Математичні операції над множинами  <<<<<<<<<<
# Давайте детальніше розглянемо, які корисні математичні операції можна робити над множинами. Спершу створимо множини a та b:

a = set('hello')
print(a)    # {'e', 'h', 'l', 'o'}

b = set('hi there!')
print(b)    # {'r', ' ', 'i', 'e', '!', 'h', 't'}

# Щоб знайти загальні елементи для двох множин, виконаємо над ними операцію & (AND):

a & b   # {'e', 'h'}

# Знайдемо усі елементи з двох множин, окрім загальних, за допомогою оператора ^ (XOR):

a ^ b   # {' ', '!', 'i', 'l', 'o', 'r', 't'}

# Об'єднання множин, або просто усі елементи з обох множин знаходяться за допомогою оператора | (OR):

a | b   # {' ', '!', 'e', 'h', 'i', 'l', 'o', 'r', 't'}

# Множини — це дуже потужний інструмент, коли необхідно знайти унікальні елементи в якомусь наборі і прибрати дублікати. 
# Множини — це також найшвидший спосіб знайти загальні або відмінні елементи з декількох наборів.


#                 >>>>>>>>>>>>>> Рядки <<<<<<<<<<<<<<<<<<<

# Робота з текстовими даними у Python реалізована через str-об'єкти або рядки.
# Рядок — це незмінна впорядкована послідовність символів в деякому кодуванні. За замовчуванням використовується кодування UTF-8, 
# але можна працювати майже з усіма відомими таблицями кодування символів. Для того щоб створити змінну типу "рядок", необхідно певний набір символів взяти в лапки.

# Варіант 1. Одинарні лапки (апостроф) 'some text'
# Варіант 2. Подвійні лапки "some text".
# Різні варіанти використання лапок обумовлені тим, що при використанні одинарних лапок, можна в рядку вказати подвійні і навпаки.

game_string = 'My "Game"'

# Впорядкована послідовність означає, що до елементів рядку можна звертатися за індексом:

s = "Hello world!"
print(s[0])   # H
print(s[-1])  # !

# Незмінна послідовність означає, що якщо рядок вже створений, то змінити його не можна, можна тільки створити новий.

s = "Hello world!"
s[0] = "Q" # Тут буде викликано виняток (помилка) TypeError

# Малі методи

# Для того, щоб усі літери рядка перевести у верхній регістр, використовується метод upper:

s = "Hello"
s.upper()
print(s)    # Виведе 'HELLO'

# Для переведення в нижній регістр використовується метод lower():

s = "Some Text"
print(s.lower())    # Виведе 'some text'

# Щоб перевірити, що рядок починається з підрядка, є метод startswith:

s = "Bill Jons"
print(s.startswith("Bi"))   # Виведе True

s = "hello.jpg"
print(s.endswith("jpg"))    # Виведе True

# Цей метод зручно використовувати для перевірки розширення файлів.

# Ми розробляємо кулінарний блог. І в рецептах, при написанні списку інгредієнтів, ми розділяємо їх комами, а перед останнім ставимо союз "and", як у прикладі нижче:

# 2 eggs, 1 liter sugar, 1 tsp salt and vinegar
# Напишіть функцію format_ingredients, яка прийматиме на вхід список з інгредієнтів ["2 eggs", "1 liter sugar", "1 tsp salt", "vinegar"] та повертатиме рядок зібраний з його елементів в описаний вище спосіб. 
# Ваша функція має вміти обробляти списки будь-якої довжини.

def format_ingredients(items):
    if not items: 
        return "" # якщо в рядку немає символів повертаємо пустий рядок
    if len(items) == 1: 
        return items[0] # якщо в рядку тільки один символ повертаємо 1 символ
    result =  ", ".join(items[:-1]) + " and " + items[-1] # 
    return result
print(format_ingredients(["2 eggs", "1 liter sugar", "1 tsp salt", "vinegar"]))

# Реалізуйте дві функції. Перша буде використовуватись у бухгалтерії при розрахунку стипендії, get_grade приймає ключ у вигляді оцінки ECTS,
# і має повертати відповідну п'ятибальну оцінку (перший стовпчик таблиці). Друга get_description теж приймає ключ у вигляді оцінки ECTS, але
# повертатиме пояснення оцінки в текстовому форматі (останній стовпчик таблиці) і буде використана в електронній заліковій книжці студента.
# На відсутній ключ функції повинні повертати значення None .

def get_grade(key):
    ECTS = {'F': 1, 'FX': 2, 'E': 3, 'D': 3, 'C': 4, 'B': 5, 'A': 5}
    if key in ECTS:
        x = ECTS.get(key)
        return x


def get_description(key):
    
    ECTS = {'F': 'Unsatisfactorily', 'FX': 'Unsatisfactorily', 'E': 'Enough', 'D': 'Satisfactorily', 'C': 'Good', 'B': 'Very good', 'A': 'Perfectly'}
    if key in ECTS:
        y = ECTS.get(key)
        return y
    
# 
def is_valid_password(password):
    # Перевірка довжини пароля
    if len(password) != 8:
        return False

    # Перевірка наявності літери у верхньому регістрі
    pin_upper = False    
    for char in password:
        if char.isupper():
            pin_upper = True
            break

    # Перевірка наявності літери у нижньому регістрі
    pin_lower = False 
    for char in password:
        if char.islower():
            pin_lower = True
            break

    # Перевірка наявності цифри
    pin_digit = False  
    for char in password:
        if char.isdigit():
            pin_digit = True
            break

    # Перевірка наявності символу
    pin_symbol = False
    for char in password:
        if char in "+-*/,./":
            pin_symbol = True
            break       

    # Повертає True, якщо всі критерії виконані
    return pin_upper and pin_lower and pin_digit and pin_symbol

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Приклади <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# У нас є список показань заборгованостей з комунальних послуг наприкінці місяця. Заборгованості можуть бути від'ємними — у нас переплата, чи додатними, якщо необхідно сплатити за рахунками.
# Напишіть функцію amount_payment, яка приймає на вхід список платежів, підсумовує додатні значення та повертає суму платежу наприкінці місяця.

def amount_payment(payment):
    amount_payment = [1, -3, 4]
    sum = 0
    for value in payment:
        if value > 0:
            sum = sum + value
    return sum 


# При аналізі даних часто виникає необхідність позбавитися екстремальних значень, перш ніж почати працювати з даними далі. Напишіть функцію prepare_data,
# яка видаляє з переданого списку найбільше та найменше значення, сортує його в порядку зростання і повертає змінений список як результат.

def prepare_data(data):
    # data = [1, -3, 4, 100, 0, -5, 10, 1, 1]
    data.remove(min(data))
    data.remove(max(data))
    new_data = sorted(data)
    return new_data
    prepare_data(data)
    print(new_data)

# Ми розробляємо кулінарний блог. І в рецептах, при написанні списку інгредієнтів, ми розділяємо їх комами, а перед останнім ставимо союз "and", як у прикладі нижче:
# 2 eggs, 1 liter sugar, 1 tsp salt and vinegar
# Напишіть функцію format_ingredients, яка прийматиме на вхід список з інгредієнтів ["2 eggs", "1 liter sugar", "1 tsp salt", "vinegar"] та повертатиме рядок
# зібраний з його елементів в описаний вище спосіб. Ваша функція має вміти обробляти списки будь-якої довжини.

def format_ingredients(items):
    if not items:
        return ""
    if len(items) == 1:
        return items[0]
    result =  ", ".join(items[:-1]) + " and " + items[-1]
    return result
print(format_ingredients(["2 eggs", "1 liter sugar", "1 tsp salt", "vinegar"]))
    
# Реалізуйте дві функції. Перша буде використовуватись у бухгалтерії при розрахунку стипендії, get_grade приймає ключ у вигляді оцінки ECTS, і має повертати 
# відповідну п'ятибальну оцінку (перший стовпчик таблиці). Друга get_description теж приймає ключ у вигляді оцінки ECTS, але повертатиме пояснення оцінки в текстовому форматі
# (останній стовпчик таблиці) і буде використана в електронній заліковій книжці студента. На відсутній ключ функції повинні повертати значення None .

def get_grade(key):
    ECTS = {'F': 1, 'FX': 2, 'E': 3, 'D': 3, 'C': 4, 'B': 5, 'A': 5}
    if key in ECTS:
        x = ECTS.get(key)
        return x


def get_description(key):
    
    ECTS = {'F': 'Unsatisfactorily', 'FX': 'Unsatisfactorily', 'E': 'Enough', 'D': 'Satisfactorily', 'C': 'Good', 'B': 'Very good', 'A': 'Perfectly'}
    if key in ECTS:
        y = ECTS.get(key)
        return y
    
# Як ми знаємо, ключ у словнику має бути унікальним, тоді як значення його ні. Реалізуйте функцію lookup_key для пошуку всіх ключів за значенням у словнику. Першим параметром 
# у функцію ми передаємо словник, а другим — значення, що хочемо знайти. Таким чином, результат може бути як список ключів, так і порожній список, якщо ми нічого не знайдемо

def lookup_key(data, value):
    x = list()
    for key, val in data.items():
        if val == value:
            x.append (key)
    return x

# У нас є список показників студентів групи – це список з отриманими балами з тестування. Необхідно поділити список на дві частини. Напишіть функцію split_list, 
# яка приймає список (цілі числа), знаходить середнє значення бала у списку та ділить його на два списки. У перший потрапляють значення менше середнього, включаючи середнє значення,
# тоді як у другий — строго більше від середнього. Функція повертає кортеж цих двох списків. Для порожнього списку повертаємо два порожні списки.

def split_list(grade):
    if len(grade) == 0:
        return [], []
    average = sum(grade) / len(grade)
    my_list_average = []
    my_list_else = []
    for char in grade:
        if char > average:
            my_list_average.append(char)
        else:
            my_list_else.append(char)
    return  my_list_else, my_list_average


# Є чотирикутна схема польотів дронів з координатами (0, 1, 2, 3). У нас є словник points, ключі якого — кортежі, точки польоту між координатами чотирикутника, вигляду (1, 2). 
# Значення словника — це відстані між вказаними точками.
# Приклад:
# points = {(0, 1): 2, (0, 2): 3.8, (0, 3): 2.7, (1, 2): 2.5, (1, 3): 4.1, (2, 3): 3.9}
# Напишіть функцію calculate_distance, яка на вхід приймає список координат чотирикутника зі словника виду [0, 1, 3, 2, 0]. Функція повинна підрахувати, використовуючи вказаний словник,
# яку загальну відстань пролетить дрон, рухаючись між точками польоту.
# Примітки:
# коли беремо у словника points значення, у ключі кортежі завжди має бути першою координата з меншим значенням — (2, 3), але не (3, 2);
# для порожнього списку та списку з однією координатою функція calculate_distance має повертати 0.

points = {
    (0, 1): 2,
    (0, 2): 3.8,
    (0, 3): 2.7,
    (1, 2): 2.5,
    (1, 3): 4.1,
    (2, 3): 3.9,
}


def calculate_distance(coordinates):
    if not coordinates and len(coordinates) == 1:
        return 0
    total_distance = 0
    for i in range(len(coordinates) - 1):
        point1 = min(coordinates[i], coordinates[i+1])
        point2 = max(coordinates[i], coordinates[i+1])
        if (point1, point2) in points:
            total_distance += points[(point1, point2)]
    return total_distance


# Потрібно написати функцію реалізації наступного ігрового алгоритму. На вхід функції game подається два аргументи: список, що складається зі списків, та початкове значення
# power - енергія гравця. Внутрішні списки — це списки з числовим значенням енергії, які може поглинути гравець, якщо вони менші або дорівнюють його енергії. Після поглинання елементу
# списку він рухається за списком далі та, або поглинає список повністю до кінця, або, якщо знаходить енергію вище за власну, залишає його і переходить до наступного списку. 
# Наприкінці обходу всіх списків функція повинна повернути загальну отриману енергію гравця.
# Приклад списку:
# [[1, 1, 5, 10], [10, 2], [1, 1, 1]]
# Для цього списку і початкової енергії рівної 1 гравець поглине з першого списку перші два значення і залишить його, зустрівши значення 5, через те, що на цей момент матиме енергію в 3.
# Другий список пропустить відразу, а третій повністю поглине та отримає остаточну енергію в 6.

def game(terra, power):
    # power = 1
    # terra = [[1, 1, 5, 10], [10, 2], [1, 1, 1]]
    for sublist in terra:
        for energy in sublist:
            if power >= energy:
                power += energy
            if power < energy:
                break
    return power


# Всім відомо, що для доступу до кредитної картки банку потрібний пін-код. Класично склалося, що це поєднання чотири цифри. Нам необхідно вирішити наступне програмістське завдання.
# Є підготовлений перелік пін-кодів. Напишіть функцію is_valid_pin_codes, яка буде приймати як параметр список цих пін-кодів — рядок з чотирьох цифр і повертати логічне 
# значення — валідний список чи ні. Переконайтеся, що серед цих пін-кодів у списку не буде дублікатів, всі вони зберігаються у вигляді рядків, їх довжина дорівнює 4 символам і містять
# вони тільки цифри.
# Приклад аргументу для функції is_valid_pin_codes:
# ['1101', '9034', '0011']
# Якщо список відповідає всім поставленим умовам, функція повертає логічне значення True. Якщо хоч одну з умов порушено, повертається значення — False. 
# Передбачити перевірку на порожній список в аргументі функції та повернути при цьому значення False.

def is_valid_pin_codes(pin_codes):
    set_pin_code = set(pin_codes)  # створюємо нову множину set_pin_code 
    if len(pin_codes) == 0:  # умова якщо довжина пін кодес 0 тоді ретурн фолс
        return False  #
    if len(set_pin_code) != len(pin_codes):# якщо довжина множини і довжина пін коду
        return False  # не дорівнюють одне одному фолс
    for el in pin_codes:  # перебираємо елементи у пін кодах
        if len(el) != 4:  # якщо довжина перебраного елементу менша за 4 тоді фолс
            return False  #
        try:  # виняток спробувати 
            int(el)  # переводимо до інта
        except ValueError:  # вказуєм виняток , якщо ValueError тоді фолс
            return False  # 
    return True  # повертаємо результат циклу


# І, нарешті, третій, останній етап. Використовуючи рішення із попередніх двох завдань, напишіть функцію get_password, яка згенерує нам випадковий надійний пароль та поверне його. 
# Алгоритм простий — ми генеруємо пароль за допомогою функції get_random_password і, якщо він проходить перевірку на надійність функцією is_valid_password, 
# повертаємо його, якщо ні — повторюємо ітерацію знову.
# Примітка: Хорошою практикою буде обмежити кількість спроб (наприклад, до 100), щоб не отримати нескінченний цикл.

from random import randint


def get_random_password():
    result = ""
    count = 0
    while count < 8:
        random_symbol = chr(randint(40, 126))
        result = result + random_symbol
        count = count + 1
    return result


def is_valid_password(password):
    if len(password) != 8:
        return False

    has_upper = False
    has_lower = False
    has_num = False

    for ch in password:
        if ch.isupper():
            has_upper = True
        elif ch.islower():
            has_lower = True
        elif ch.isdigit():
            has_num = True

    return has_upper and has_lower and has_num


def get_password():
    
    attempt_max = 100
    attempt = 0
    while attempt < attempt_max :
        password = get_random_password()
        if is_valid_password(password):
            return password
        attempt += 1


# Напишіть функцію parse_folder, вона приймає єдиний параметр path, який є об'єктом Path. Функція повинна просканувати директорію path та повернути кортеж із двох списків.
# Перший — це список файлів усередині директорії, другий — список директорій.

def parse_folder(path):
    files = []
    folders = []
    
    for item in path.iterdir():
        if item.is_file():
            files.append(item.name)
        elif item.is_dir():
            folders.append(item.name)

        
    return files, folders

# Створіть функцію parse_args, яка повертає рядок, складений з аргументів командного рядка, розділених пробілами. Наприклад, якщо скрипт був викликаний командою: 
# python run.py first second, то функція parse_args повинна повернути рядок наступного виду 'first second'

import sys


def parse_args():
    result = "first second"
    
    return result

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Тиждень 5  Просунута робата з рядками  <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# Напишіть функцію real_len, яка підраховує та повертає довжину рядка без наступних керівних символів: [\n, \f, \r, \t, \v]
# Для перевірки правильності роботи функції real_len їй будуть передані наступні рядки: # 'Alex\nKdfe23\t\f\v.\r'   # 'Al\nKdfe23\t\v.\r'

def real_len(text):
    delete_symvol = '[\n, \f, \r, \t, \v]'
    translation_map = str.maketrans("", "", delete_symvol) # Створюємо мапу перекладу, яка видаляє символи, які ми хочемо виключити
    new_text = text.translate(translation_map)# Використовуємо метод translate() для виключення символів та отримання результуючого рядка
    lenght = len(new_text) # Підраховуємо довжину модифікованого рядка
    print(lenght)
    return lenght

# Ваша компанія веде блог. Треба реалізувати функцію find_articles для пошуку за статтями цього блогу. Є список articles_dict, в якому міститься опис статей блогу. Кожен елемент цього списку
# є словником з наступними ключами: прізвища авторів - ключ 'author', назва статті - ключ 'title', рік видання - ключ 'year'. Реалізуйте функцію find_articles,
# Параметр key функції визначає поєднання букв для пошуку. Наприклад, при key="Python" функція шукає, чи є у списку articles_dict статті, у назві чи іменах авторів яких зустрічається
# це поєднання літер. Якщо такі елементи списку були знайдені, треба повернути новий список зі словників, що містять прізвища авторів, назву та рік видання всіх таких статей.
# Другий ключовий параметр функції letter_case визначає, чи треба враховувати під час пошуку регістр літер. За умовчанням він дорівнює False і регістр немає значення
# тобто пошук в тексті "Python" і "python" це те ж саме. Інакше потрібно шукати повний збіг.

articles_dict = [
    {
        "title": "Endless ocean waters.",
        "author": "Jhon Stark",
        "year": 2019,
    },
    {
        "title": "Oceans of other planets are full of silver",
        "author": "Artur Clark",
        "year": 2020,
    },
    {
        "title": "An ocean that cannot be crossed.",
        "author": "Silver Name",
        "year": 2021,
    },
    {
        "title": "The ocean that you love.",
        "author": "Golden Gun",
        "year": 2021,
    },
]

def find_articles(key, letter_case=False):
    # Ініціалізація порожнього списку для результатів
    result = []

    # Перевірка, чи слід враховувати регістр літер
    if letter_case:
        # Якщо слід враховувати регістр літер, ітеруємося через статті
        for article in articles_dict:
            # Ітерація через ключі та значення словника статті
            for keys, value in article.items():
                # Перевірка, чи ключове слово є в значенні (з урахуванням регістру літер)
                if key in str(value):
                    # Додавання статті до результатів, якщо умова виконується
                    result.append(article)
    else:
        # Якщо не слід враховувати регістр літер, ітеруємося через статті
        for article in articles_dict:
            # Ітерація через ключі та значення словника статті
            for keys, value in article.items():
                # Перевірка, чи ключове слово є в значенні (без урахування регістру літер)
                if key.lower() in str(value).lower():
                    # Додавання статті до результатів, якщо умова виконується
                    result.append(article)

    # Повернення результатів
    return result
# Примітка:
# Важливою є передача articles_dict як параметру у функцію. У вашій функції це не зроблено, і це може призвести до помилки.
# Пам'ятайте, що ви можете використовувати key.lower() одразу при ітерації через словники, щоб уникнути повторювання коду.



# Ваша компанія проводить маркетингові кампанії за допомогою SMS-розсилок. Автоматичний збір телефонних номерів із бази даних формує певний перелік. Але клієнти залишають свої номери у
# довільному вигляді:
#     "    +38(050)123-32-34",
#     "     0503451234",
#     "(050)8889900",
#     "38050-111-22-22",
#     "38050 111 22 11   ",
# Сервіс розсилок чудово розуміє і може відправити SMS клієнту, тільки якщо телефонний номер містить правильні цифри. Необхідно реалізувати функцію sanitize_phone_number, 
# яка прийматиме рядок з телефонним номером та буде нормалізувати його, тобто. буде прибирати символи (, -, ), + та пробіли.
# Результат:
# 380501233234
# 0503451234
# 0508889900
# 380501112222
# 380501112211
#  Є два варінти розвязання 
# мій 
def sanitize_phone_number(phone):
    
    chars_to_remove = "()\-\+" # створюємо список символів які не потрібні
    for char in chars_to_remove: # якщо символ є в ремов символ тоді
        phone = phone.replace(char, "") # видалаяємо з тел символи
    phone = phone.replace(" ", "") # видалення пробілів окремо
    return phone
    print(phone.strip()) # друкуємо без відступів

# Мій з використанням регулярки

import re
def sanitize_phone_number(phone): 
    new_phone = re.sub(r'[()\-\+\s]', '', phone)  # створюємо нову змінну і через re.sub заміняємо непотрібні символи на ніщо(видаляємо) r`[що міняємо], '' - на що міняємо, phone - де міняємо
    print(new_phone.strip())
        
sanitize_phone_number("38050 111 22 11   ")

# Грамотно написаний 
def sanitize_phone_number(phone):
    new_phone = (
        phone.strip()
        .removeprefix("+") # d
        .replace("(", "")
        .replace(")", "")
        .replace("-", "")
        .replace(" ", "")
    )
    return new_phone








# Повернемося до нашого завдання із телефонними номерами. Компанія розширюється та вийшла на ринок Азії. Тепер у списку можуть знаходитись телефони різних країн. Кожна країна має свій
# телефонний код .
# Компанія працює з наступними країнами
# Країна	Код ISO	Префікс
# Japan	JP	+81
# Singapore	SG	+65
# Taiwan	TW	+886
# Ukraine	UA	+380
# Щоб ми могли коректно виконати рекламну SMS кампанію, необхідно створити для кожної країни свій список телефонних номерів.Напишіть функцію get_phone_numbers_for_сountries, яка буде:
# Приймати список телефонних номерів. Санітизувати (нормалізувати) отриманий список телефонів клієнтів за допомогою нашої функції sanitize_phone_number.
# Сортувати телефонні номери за вказаними у таблиці країнами.Повертати словник зі списками телефонних номерів для кожної країни у такому вигляді:
# {
#     "UA": [<тут список телефонів>],
#     "JP": [<тут список телефонів>],
#     "TW": [<тут список телефонів>],
#     "SG": [<тут список телефонів>]
# }
# Якщо не вдалося порівняти код телефону з відомими, цей телефон повинен бути доданий до списку словника з ключем 'UA'.
def sanitize_phone_number(phone):
    new_phone = (
        phone.strip()
        .removeprefix("+")
        .replace("(", "")
        .replace(")", "")
        .replace("-", "")
        .replace(" ", "")
    )
    return new_phone


def get_phone_numbers_for_countries(list_phones):
    dict_phone = {  # створюємо словник
    "UA": [],  # 38
    "JP": [],  # 81
    "TW": [],  # 88
    "SG": []   #65
    }
    for phone in list_phones: # запускаємо цикл пошуку телефону в списку телефоніві
        sanitized_phone = sanitize_phone_number(phone) # створюємо нову змінну "sanitized_phone" яка буде брати телефон і по функції вище його очищати
        if sanitized_phone.startswith ("81"):  # коли тел пройшов функцію "sanitize_phone_number" перевіряємо з якої цифри він починається, якщо ні то далі
            dict_phone["JP"].append(sanitized_phone) # якщо умова вище виконана тоді в словник "dict_phone" а конкретно в список ["JP"] додаємо відредагований телефон
            print(f"Japan : {sanitized_phone}")  # прінтуємо назву країни і відредагований телефон
        elif sanitized_phone.startswith ("65"): # коли тел пройшов функцію "sanitize_phone_number", і не попав під першу умову, тоді перевіряємо другу
            dict_phone["SG"].append(sanitized_phone) # якщо умова вище виконана тоді в словник "dict_phone" а конкретно в список ["SG"] додаємо відредагований телефон
            print(f"Singapore : {sanitized_phone}")# прінтуємо назву країни і відредагований телефон
        elif sanitized_phone.startswith ("88"): # коли тел пройшов функцію "sanitize_phone_number", і не попав під другу умову, тоді перевіряємо третю
            dict_phone["TW"].append(sanitized_phone) # якщо умова вище виконана тоді в словник "dict_phone" а конкретно в список ["TW"] додаємо відредагований телефон
            print(f"Taiwan : {sanitized_phone}")# прінтуємо назву країни і відредагований телефон
        elif sanitized_phone.startswith ("38"): # коли тел пройшов функцію "sanitize_phone_number", і не попав під третю умову, тоді перевіряємо четверту
            dict_phone["UA"].append(sanitized_phone) # якщо умова вище виконана тоді в словник "dict_phone" а конкретно в список ["UA"] додаємо відредагований телефон
            print(f"Ukraine : {sanitized_phone}")# прінтуємо назву країни і відредагований телефон
        else:
            dict_phone["UA"].append(sanitized_phone) # якщо телефон нікуди не підійшов додаємо відредаговани телефон до словника UA
            print(f"Ukraine : {sanitized_phone}")# прінтуємо назву країни і відредагований телефон
    return dict_phone



# Розглянемо завдання на перевірку спаму в електронному листі або фільтрацію заборонених слів у повідомленні. Нехай функція is_spam_words приймає рядок (параметр text),
# перевіряє його на вміст заборонених слів зі списку (параметр spam_words), і повертає результат перевірки: True, якщо є хоч одне слово присутнє зі списку, та False, 
# якщо в тексті стоп-слів не виявлено. Слова у параметрі text можуть бути у довільному регістрі, а значить функція is_spam_words, при пошуку заборонених слів, регістру незалежна і весь текст
# має зводитися до нижнього регістру. Для спрощення, будемо вважати, що в рядку є тільки одне заборонене слово.Передбачити третій параметр функції space_around, 
# який за замовчуванням дорівнює False. Він відповідатиме за те, що функція шукатиме окреме слово чи ні. Слово вважати, що стоїть окремо, якщо ліворуч від слова знаходиться символ
# пробілу або воно розташоване на початку тексту, а праворуч від слова знаходиться пробіл або символ крапки.

import re
def is_spam_words(text, spam_words, space_around=False):
  for word in spam_words: # перебираємо чи слово є в спам словах
      if space_around: # якщо space_around True тоді:
           pattern = rf'\b{re.escape(word)}\b'# формуємо патерн regex 
           if re.search(pattern, text):# Перевіряємо, слово є в текст
                return True # якщо є повертаємо True, якщо ні йдем в else
      else:
          if word in text:  # перевіряємо, чи є слово в тексті
                return True # Якщо є, то повертаємо True
  return False # Якщо жодне спам-слово не було знайдено, повертаємо Fals

# Приклад використання:
result = is_spam_words('Молох бог ужасен.', ['лох'])
print(result)  # Повинно вивести True


# Ви вже навчилися працювати з рядками глибше і тепер у вас є повний набір інструментів для обробки рядків за допомогою Python.За допомогою функції zip, за аналогією прикладу теорії,
# створіть словник TRANS для транслітерації. Створюйте словник TRANS поза функцією translateНапишіть функцію translate, яка проводить транслітерацію кириличного алфавіту на латинську.
# Функція translate:
# приймає на вхід рядок та повертає рядок;
# проводить транслітерацію кириличних символів на латиницю;
# Приклад виконання:
# print(translate("Дмитро Короб"))  # Dmitro Korob
# print(translate("Олекса Івасюк"))  # Oleksa Ivasyuk
# Примітка: У задачі, при створенні словника TRANS, код TRANS[ord(c.upper())] = l.title() буде вважатися неправильним, а TRANS[ord(c.upper())] = l.upper() — правильним.
# Це компроміс, тому що в першому випадку ми враховуємо великі літери, а в другому — правильно, якщо ім'я буде все великими літерами. 
# Щоб не ускладнювати завдання, прийнято як у документах — все ім'я друкується великими.


CYRILLIC_SYMBOLS = "абвгдеёжзийклмнопрстуфхцчшщъыьэюяєіїґ"
TRANSLATION = ("a", "b", "v", "g", "d", "e", "e", "j", "z", "i", "j", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u",
               "f", "h", "ts", "ch", "sh", "sch", "", "y", "", "e", "yu", "ya", "je", "i", "ji", "g")
# Визначаємо два списки: CYRILLIC_SYMBOLS, що містить кириличні символи, та TRANSLATION, що містить їхні транслітерації.

TRANS = {}  # створюємо пустий словник


for c, t in zip(CYRILLIC_SYMBOLS, TRANSLATION): # Для кожної пари кириличного символу та його транслітерації оновлюємо словник TRANS для обох форм - в нижньому та верхньому регістрах.
    # c, t це змінні двох елементів с = CYRILLIC_SYMBOLS / а змінна t = TRANSLATION
    # функція zip, об'єднує елементи двох списків у кортежі 
    TRANS[ord(c)] = t
    TRANS[ord(c.upper())] = t.upper()
    print(TRANS)


def translate(name): # Визначаємо функцію 'translate', яка приймає параметр 'name'.
    name_trans = name.translate(TRANS) # Використовуємо метод translate для рядка 'name' з використанням словника TRANS для транслітерації.
    return name_trans # Повертаємо транслітероване ім'я.





# У минулому модулі ми працювали із системою оцінок ECTS. Напишіть функцію formatted_grades, яка приймає на вхід словник оцінювання студентів за предмет наступного вигляду:
# students = {"Nick": "A", "Olga": "B", "Mike": "FX", "Anna": "C"}
# І повертає список відформатованих рядків, щоб під час виведення наступного коду:
# for el in formatted_grades(students):
#     print(el)
# Виходила наступна таблиця:

#    1|Nick      |  A  |  5
#    2|Olga      |  B  |  5
#    3|Mike      | FX  |  2
#    4|Anna      |  C  |  4
# перший стовпець — ширина 4 символи, вирівнювання по правому краю
# другий стовпець — ширина 10 символів, вирівнювання по лівому краю
# третій та четвертий стовпець — ширина 5 символів, вирівнювання по центру
# вертикальний символ | не входить у ширину стовпця

grades = {"A": 5, "B": 5, "C": 4, "D": 3, "E": 3, "FX": 2, "F": 1}


def formatted_grades(students):
    formatted_list = []
    for i, (name, grade) in enumerate(students.items(), start=1):
        formatted_list.append("{:>4}|{:<10}|{:^5}|{:^5}".format(i, name, grade, grades.get(grade)))
    
    for line in formatted_list:
        print(line)
    return formatted_list






# Попрацюємо трохи зі специфікацією у форматуванні рядків. Напишіть функцію formatted_numbers, яка повертає список відформатованих рядків, щоб під час виведення наступного коду:
# for el in formatted_numbers():
#     print(el)
# Виходила наступна таблиця:
# | decimal  |   hex    |  binary  |
# |0         |    0     |         0|
# |1         |    1     |         1|
# |2         |    2     |        10|
# |3         |    3     |        11|
# |4         |    4     |       100|
# |5         |    5     |       101|
# |6         |    6     |       110|
# |7         |    7     |       111|
# |8         |    8     |      1000|
# |9         |    9     |      1001|
# |10        |    a     |      1010|
# |11        |    b     |      1011|
# |12        |    c     |      1100|
# |13        |    d     |      1101|
# |14        |    e     |      1110|
# |15        |    f     |      1111|
# всі стовпці мають ширину 10 символів
# у заголовків таблиці вирівнювання по центру
# перший стовпець десяткових чисел — вирівнювання по лівому краю
# другий стовпець шістнадцяткових чисел — вирівнювання по центру
# третій стовпець двійкових чисел — вирівнювання з правого краю
# вертикальний символ | не входить у ширину стовпця
# Як ви вже зрозуміли, функція formatted_numbers виводить таблицю чисел від 0 до 15 у десятковому, шістнадцятковому та бінарному форматі.


def formatted_numbers():
    num_list = ["|{:^10}|{:^10}|{:^10}|".format("decimal", "hex", "binary")] 
    for num in range(16):
        num_list.append("|{:<10d}|{:^10x}|{:>10b}|".format(num, num, num))
    
    for line in num_list:
        print(line)
    
    return num_list

# Виклик функції
formatted_numbers()




# Напишіть функцію find_word, яка приймає два параметри: перший text та другий word. Функція виконує пошук зазначеного слова word у тексті text за допомогою функції search та повертає словник.
# При виклику функції:
# print(find_word(
#     "Guido van Rossum began working on Python in the late 1980s, as a successor to the ABC programming language, and first released it in 1991 as Python 0.9.0.",
#     "Python"))
# Результат має бути наступного виду при збігу:
# {
#     'result': True,
#     'first_index': 34,
#     'last_index': 40,
#     'search_string': 'Python',
#     'string': 'Guido van Rossum began working on Python in the late 1980s, as a successor to the ABC programming language, and first released it in 1991 as Python 0.9.0.'
# }
# де
# result — результат пошуку True або False
# first_index — початкова позиція збігу
# last_index — кінцева позиція збігу
# search_string — частина рядка, в якому був збіг
# string — рядок, переданий у функцію
# Якщо збігів не виявлено:

# print(find_word(
#     "Guido van Rossum began working on Python in the late 1980s, as a successor to the ABC programming language, and first released it in 1991 as Python 0.9.0.",
#     "python"))
# Результат:
# {
#     'result': False,
#     'first_index': None,
#     'last_index': None,
#     'search_string': 'python',
#     'string': 'Guido van Rossum began working on Python in the late 1980s, as a successor to the ABC programming language, and first released it in 1991 as Python 0.9.0.'
# }


# ВИРІШЕННЯ
def find_word(text, word):
    # Створення словника для зберігання результатів пошуку та вхідних даних
    result_dict = {
        'result': False,        # Позначає, чи було знайдено входження слова
        'first_index': None,    # Початковий індекс знайденого входження
        'last_index': None,     # Кінцевий індекс знайденого входження
        'search_string': word,  # Слово, яке шукається
        'string': text          # Текст, в якому проводиться пошук
    }

    # Здійснюємо пошук слова у тексті
    match = re.search(word, text)

    # Перевірка, чи було знайдено входження слова
    if match:
        result_dict['result'] = True
        result_dict['first_index'] = match.span()[0]
        result_dict['last_index'] = match.span()[1]
        result_dict['search_string'] = match.group()
    
    # Виведення результатів пошуку на екран
    print(result_dict)

    # Повернення словника з результатами пошуку
    return result_dict 

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  Тиждень 6 Робота з файлами <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

# Нехай ми маємо текстовий файл, який містить дані з місячною заробітною платою по кожному розробнику компанії.
# Приклад файлу:
# Alex Korp,3000
# Nikita Borisenko,2000
# Sitarama Raju,1000
# Як бачимо, структура файлу – це прізвище розробника та значення його заробітної плати, розділеної комою.
# Розробіть функцію total_salary(path) (параметр path - шлях до файлу), яка буде розбирати текстовий файл і повертати загальну суму заробітної плати всіх розробників компанії.

def total_salary(path):
    
    fh = open(path, 'r')
    total = 0.0
    line = fh.readline()
    while line:
        # Розбиваємо рядок за допомогою коми
        parts = line.split(',')
        print(parts)
        # Додаємо заробітну плату розробника до загальної суми
        total += float(parts[1])
        print(total)

        line = fh.readline() # Читаємо наступний рядок

    fh.close() # Закриваємо файл

    # Повертаємо загальну суму заробітної плати у вигляді float
    return total






# У компанії є кілька відділів. Список працівників для кожного відділу має такий вигляд:
# ['Robert Stivenson,28', 'Alex Denver,30']
# Це список рядків із прізвищем та віком співробітника, розділеними комами.
# Реалізуйте функцію запису даних про співробітників у файл, щоб інформація про кожного співробітника починалася з нового рядка.
# Функція запису в файл write_employees_to_file(employee_list, path), де:
# path – шлях до файлу.
# employee_list - список зі списками співробітників по кожному відділу, як у прикладі нижче:
# [['Robert Stivenson,28', 'Alex Denver,30'], ['Drake Mikelsson,19']]
# Вимоги:
# запишіть вміст employee_list у файл, використовуючи режим "w".
# ми поки що не використовуємо менеджер контексту with
# кожен співробітник повинен бути записаний з нового рядка — тобто для попереднього списку вміст файлу має бути наступним:
# Robert Stivenson,28
# Alex Denver,30
# Drake Mikelsson,19


def write_employees_to_file(employee_list, path):
     fh = open(path, 'w')
    # Записуємо кожен рядок зі списку employee_list в файл
     for employee in employee_list:
         for line in employee:
            fh.write(line + '\n')  # Додаємо символ нового рядка між рядками
     print(employee)
     

     fh.close()





# У попередній задачі ми записали співробітників у файл у такому вигляді:

# Robert Stivenson,28
# Alex Denver,30
# Drake Mikelsson,19
# Виконаємо тепер зворотнє завдання і створимо функцію read_employees_from_file(path), яка читатиме дані з файлу та повертатиме список співробітників у вигляді:

# ['Robert Stivenson,28', 'Alex Denver,30', 'Drake Mikelsson,19']
# Пам'ятайте про наявність символу кінця рядка \n під час читання даних із файлу. Його необхідно прибирати при додаванні прочитаного рядка до списку.

# Вимоги:

# прочитайте вміст файлу за допомогою режиму "r".
# ми поки що не використовуємо менеджер контексту with
# поверніть із функції список співробітників із файлу



def read_employees_from_file(path):
    # Створення порожнього списку для зберігання інформації про співробітників
    list = []

    # Відкриття файлу для читання
    fh = open(path, 'r')

    # Цикл, що перебирає кожен рядок у файлі
    for line in fh:
        # Видалення пробілів з початку та кінця рядка (включаючи символ нового рядка)
        line = line.strip()

        # Додавання очищеного рядка до списку
        list.append(line)

    # Закриття файлу
    fh.close()

    # Повернення списку інформації про співробітників
    return list




# Реалізуйте функцію add_employee_to_file(record, path), яка у файл (параметр path - шлях до файлу) буде додавати співробітника (параметр record) у вигляді рядка "Drake Mikelsson,19".

# Вимоги:

# параметр record - співробітник у вигляді рядка виду "Drake Mikelsson,19"
# кожен запис у файл має починатися з нового рядка.
# необхідно щоб стара інформація у файлі теж зберігалася, тому при роботі з файлом відкрийте файл у режимі 'a', додайте співробітника record у файл і закрийте його

def add_employee_to_file(record, path):
    
    fh = open(path, "a")
    fh.write(record + "\n")
    print(record)
    



    fh.close()



# Ми маємо таку структуру файлу:

# 60b90c1c13067a15887e1ae1,Tayson,3
# 60b90c2413067a15887e1ae2,Vika,1
# 60b90c2e13067a15887e1ae3,Barsik,2
# 60b90c3b13067a15887e1ae4,Simon,12
# 60b90c4613067a15887e1ae5,Tessi,5
# Кожен запис складається з трьох частин і починається з нового рядка. Наприклад, для першого запису початок 60b90c1c13067a15887e1ae1 — це первинний ключ бази даних MongoDB. 
# Він завжди містить 12 байтів або рівно 24 символи. Далі ми бачимо прізвисько кота Tayson та його вік 3. Всі частини запису розділені символом кома ,
# Розробіть функцію get_cats_info(path), яка повертатиме список словників із даними котів у вигляді:
# [
#     {"id": "60b90c1c13067a15887e1ae1", "name": "Tayson", "age": "3"},
#     {"id": "60b90c2413067a15887e1ae2", "name": "Vika", "age": "1"},
#     {"id": "60b90c2e13067a15887e1ae3", "name": "Barsik", "age": "2"},
#     {"id": "60b90c3b13067a15887e1ae4", "name": "Simon", "age": "12"},
#     {"id": "60b90c4613067a15887e1ae5", "name": "Tessi", "age": "5"},
# ]
# Параметри функції:
# path - шлях до файлу
# Вимоги:
# прочитайте вміст файлу за допомогою режиму "r".
# ми використовуємо менеджер контексту with
# поверніть із функції список котів із файлу у потрібному форматі

def get_cats_info(path):
    cat_list = []
    with open(path, 'r') as fh:
        while True:
            line = fh.readline()
            line = line.strip()
            if not line:
                break
            # cat_list.append(line)
            # Розділити рядок на поля, використовуючи кому як роздільник
            cat_info = line.split(',')

            # Створити словник для кожного кота та додати його до списку
            cat_dict = {'id': cat_info[0], 'name': cat_info[1], 'age': cat_info[2]}
            cat_list.append(cat_dict)
            print(cat_list)
            
    return cat_list




# Нагадаємо, що у 4 модулі ми для кулінарного блогу писали функцію format_ingredients, яка приймала на вхід список з інгредієнтами рецепта.
# Ми продовжимо працювати в цьому напрямку та створимо функцію, яка шукатиме рецепт у файлі та повертатиме знайдений рецепт у вигляді словника певної форми.
# У вас є файл, який містить рецепти у вигляді:
# 60b90c1c13067a15887e1ae1,Herbed Baked Salmon,4 lemons,1 large red onion,2 tablespoons chopped fresh basil
# 60b90c2413067a15887e1ae2,Lemon Pancakes,2 tablespoons baking powder,1 cup vanilla-flavored almond milk,1 lemon
# 60b90c2e13067a15887e1ae3,Chicken and Cold Noodles,6 ounces dry Chinese noodles,1 tablespoon sesame oil,3 tablespoons soy sauce
# 60b90c3b13067a15887e1ae4,Watermelon Cucumber Salad,1 large seedless watermelon,12 leaves fresh mint,1 cup crumbled feta cheese
# 60b90c4613067a15887e1ae5,State Fair Lemonade,6 lemons,1 cups white sugar,5 cups cold water
# Кожен рецепт записаний з нового рядка (не забуваємо під час вирішення завдання про кінець рядка). Кожен запис починається з первинного ключа бази даних MongoDB. Далі через кому,
# йде назва рецепта, а потім через кому, йде перелік інгредієнтів рецепта.
# Вам необхідно реалізувати функцію, котра буде отримувати інформацію про рецепт у вигляді словника для кожної страви що шукається. Створіть функцію get_recipe(path, search_id), 
# яка повертатиме словник для рецепта із зазначеним ідентифікатором MongoDB.
# Де параметри функції:
# path — шлях до файлу.
# search_id — первинний ключ MongoDB для пошуку рецепта
# Вимоги:
# Використовуйте менеджер контексту with для читання з файлу
# Якщо рецепта із зазначеним search_id у файлі немає, функція повинна повернути None
# Приклад: для файлу, вказаного вище, виклик функції у вигляді
# get_recipe("./data/ingredients.csv", "60b90c3b13067a15887e1ae4")
# Повинен знайти у файлі рядок 60b90c3b13067a15887e1ae4,Watermelon Cucumber Salad,1 large seedless watermelon,12 leaves fresh mint,1 cup crumbled feta cheese і повернути результат у вигляді
# словника такої структури:
# {
#     "id": "60b90c3b13067a15887e1ae4",
#     "name": "Watermelon Cucumber Salad",
#     "ingredients": [
#         "1 large seedless watermelon",
#         "12 leaves fresh mint",
#         "1 cup crumbled feta cheese",
#     ],
# }


def get_recipe(path, search_id):

    with open(path, 'r') as fh:
         while True:
            line = fh.readline()
            line = line.strip()
            if not line:
                break
             # Розділити рядок на поля, використовуючи кому як роздільник
            dict_info = line.split(',')
            # Створити словник для кожного елементу та додати його до списку
            dict_elem = {'id': dict_info[0], 'name': dict_info[1], 'ingredients': dict_info[2:5]}
            # Перевірити, чи збігається id з search_id
            if dict_info[0] == search_id:
                return dict_elem
    if not search_id:
                return None
    


# Розробіть функцію sanitize_file(source, output), що переписує у текстовий файл output вміст текстового файлу source, очищений від цифр.
# Вимоги:
# прочитайте вміст файлу source, використовуючи менеджер контексту with та режим "r".
# запишіть новий очищений від цифр вміст файлу output, використовуючи менеджер контексту with та режим "w"
# запис нового вмісту файлу output має бути одноразовий і використовувати метод write

def sanitize_file(source, output):
    # Відкриваємо вихідний файл для читання
    with open(source, 'r') as source_file:
        # Зчитуємо вміст вихідного файлу та зберігаємо його у змінну content
        content = source_file.read()
        
        # Видаляємо цифри з тексту та створюємо новий рядок clean
        clean = ''.join(char for char in content if not char.isdigit())
        
        # Виводимо очищений текст для перевірки на екран
        print(clean)

    # Відкриваємо вихідний файл для запису
    with open(output, 'w') as output_file:
        # Записуємо очищений текст у вихідний файл
        output_file.write(clean)

# clean = ''.join(char for char in content if not char.isdigit()) - цей рядок використовує генератор списку та метод join(), щоб створити новий рядок, 
# в якому відсутні всі цифри з вихідного рядка content. Давайте розглянемо деталі цього виразу:
# for char in content: Цикл проходить через кожен символ у вмісті content.
# if not char.isdigit(): Умова перевіряє, чи символ не є цифрою. char.isdigit() повертає True, якщо символ є цифрою, інакше повертає False. not char.isdigit() буде True,
# якщо символ не є цифрою.
# char for char in content if not char.isdigit(): Це генератор списку, який створює новий список, включаючи всі символи з content, які не є цифрами.
# ''.join(...): Метод join() об'єднує всі елементи відфільтрованого списку (тобто всі символи, які не є цифрами) в один рядок.
# Отже, в результаті, clean буде містити рядок, в якому відсутні всі цифри з початкового рядка content. Наприклад, якщо content - це "test text 123test", то clean буде "test text test".

# Задано відомість абітурієнтів, які склали вступні іспити до університету. Структура даних щодо абітурієнтів подана у вигляді наступного списку:

[
    {
        "name": "Kovalchuk Oleksiy",
        "specialty": 301,
        "math": 175,
        "lang": 180,
        "eng": 155,
    },
    {
        "name": "Ivanchuk Boryslav",
        "specialty": 101,
        "math": 135,
        "lang": 150,
        "eng": 165,
    },
    {
        "name": "Karpenko Dmitro",
        "specialty": 201,
        "math": 155,
        "lang": 175,
        "eng": 185,
    },
]




# У кожному словнику цього списку записано прізвище абітурієнта — ключ name, код спеціальності, на яку він поступив — ключ specialty, та отримані ним бали з
# окремих дисциплін — ключі math (математика), lang ( українська мова) та eng (англійська мова)
# Розробіть функцію save_applicant_data(source, output), яка буде вказаний список із параметра source зберігати у файл із параметра output
# Структура файлу для зберігання повинна бути наступною. У кожному новому рядку файлу повинні бути записані через кому без прогалин прізвище абітурієнта, код спеціальності, на яку він поступив, та отримані ним бали за окремими дисциплінами.

# Kovalchuk Oleksiy,301,175,180,155
# Ivanchuk Boryslav,101,135,150,165
# Karpenko Dmitro,201,155,175,185
# Вимоги:

# відкрийте файл output для запису, використовуючи менеджер контексту with та режим w.
# запис нового вмісту файлу output має бути або за допомогою методу writelines, або використовувати метод write


def save_applicant_data(source, output):
    # Відкриття файлу у режимі запису ('w'). 
    # Змінна fh (file handle) буде використовуватися для доступу до файлу.
    with open(output, 'w') as fh:
        # Створення списку lines, де кожен елемент це рядок із даними про абітурієнта.
        # Використовується генератор списку та f-string для форматування рядків.
        lines = [f"{applicant['name']},{applicant['specialty']},{applicant['math']},{applicant['lang']},{applicant['eng']}\n" for applicant in source]
        
        # Запис у файл всіх рядків зі списку lines за допомогою fh.writelines().
        fh.writelines(lines)